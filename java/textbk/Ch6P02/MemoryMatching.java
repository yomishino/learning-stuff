import java.util.Random;
import java.util.Scanner;

/**
 * A class of a game of memory matching.
 * @author yomishino
 * @version 1.0
 */
public class MemoryMatching {
    /** A table of cards arranged. */
    private Card[][] table;
    /** Total number of cards. */
    private int numCards;
    /** Total number of cards that have matched with another one. */
    private int numMatch;
    /** Whether the game is ready to play. */
    private boolean ready;
    /** A place-holder character for a position without a card. */
    private static final char NO_CARD = ' ';
    /** The default number of rows of the game table. */
    private static final int DEFAULT_HEIGHT = 4;
    /** The default number of columns of the game table. */
    private static final int DEFAULT_WIDTH = 4;
    /** The default values of cards. */
    private static final char[] VALUES = {'1', '2', '3', '4', '5', 
                                    '6', '7', '8'};
    
    /**
     * Constructs a <code>MemoryMatching</code> object representing
     * a game of memory matching.
     */
    public MemoryMatching() {
        reset();
    }

    /**
     * Resets all settings for the game, to prepare for a new game.
     */
    public void reset() {
        table = null;
        numCards = 0;
        numMatch = 0;
        ready = false;
    }

    /**
     * Generates a series of cards according to the given
     * values, make them into pairs by generating also a
     * duplicate card for each value, and returns all cards
     * in an array.
     * <p>
     * If the given values contain repetitive elements,
     * then there will be more than one pair of the same cards
     * generated by this method.
     * @param values A <code>char</code> array of the values
     * of the cards.
     * @return An array of generated <code>Card</code>s.
     */
    private Card[] generateCards(char[] values) {
        Card[] cards = new Card[values.length * 2];
        for (int i = 0; i < cards.length; i += 2) {
            cards[i] = new Card(values[i / 2]);
            cards[i + 1] = new Card(values[i / 2]);
        }
        return cards;
    }

    /**
     * Turns all the cards on the current table face down.
     */
    public void turnAllCardsDown() {
        for (int row = 0; row < table.length; row++) {
            for (Card c : table[row]) {
                if (c != null)
                    c.turnFaceDown();
            }
        }
    }

    /**
     * Checks if the game is ready to play, with all the
     * fields of settings having valid values.
     * @return A <code>boolean</code> of whether the game
     * is ready to play.
     */
    public boolean isGameReady() {
        return ready;
    }

    /**
     * Sets a new game with default settings.
     */
    public void newGame() {
        newGame(VALUES, DEFAULT_HEIGHT, DEFAULT_WIDTH);
    }

    /**
     * Sets a new game with the given cards and the
     * default table settings.
     * @param cards An array of <code>Card</code>s,
     * not necessarily in order but should be in pairs.
     */
    public void newGame(Card[] cards) {
        newGame(cards, DEFAULT_HEIGHT, DEFAULT_WIDTH);
    }

    /**
     * Sets a new game with the given cards and 
     * table settings.
     * @param cards An array of <code>Card</code>s,
     * not necessarily in order but should be in pairs.
     * @param height An <code>int</code> of the height
     * of the table for the new game.
     * @param width An <code>int</code> of the width of
     * the table for the new game.
     */
    public void newGame(Card[] cards, 
                        int height, int width) {
        reset();
        setTable(cards, height, width);
        shuffle();
        turnAllCardsDown();
        ready = true;
    }
    
    /**
     * Sets a new game with the given values to generate
     * cards, which will be used in the game.
     * <p>
     * If the given values contain repetitive elements,
     * then there will be more than one pair of the same cards
     * generated by this method.
     * @param values An array of <code>char</code>s of the
     * values of the cards.
     */
    public void newGame(char[] values) {
        newGame(values, DEFAULT_HEIGHT, DEFAULT_WIDTH);
    }

    /**
     * Sets a new game with the given table settings;
     * and cards will be generated by the given values.
     * <p>
     * If the given values contain repetitive elements,
     * then there will be more than one pair of the same cards
     * generated by this method.
     * @param values An array of <code>char</code>s of the
     * values of the cards.
     * @param height An <code>int</code> of the height
     * of the table for the new game.
     * @param width An <code>int</code> of the width of
     * the table for the new game.
     */
    public void newGame(char[] values, 
                        int height, int width) {
        Card[] cards = generateCards(values);
        newGame(cards, height, width);
    }

    /**
     * Sets the table of the game to be the given one.
     * The table should be an <i>h</i> * <i>w</i> array of 
     * <code>Card</code> objects where <i>h</i> is the height of 
     * the table and <i>w</i> the width.
     * @param table A 2D array of <code>Card</code> of an arranged
     * table of cards.
     * @param numCards An <code>int</code> of total number of cards
     * in the table.
     * @throws IllegalArgumentException if the given table is empty.
     */
    public void setTable(Card[][] table, int numCards)
                throws IllegalArgumentException {
        if (table.length == 0 || table[0].length == 0)
            throw new IllegalArgumentException("Empty table given.");
        this.table = table;
        this.numCards = numCards;
        this.numMatch = 0;
    }

    /**
     * Builds a table with the given cards and table settings,
     * then sets the game with this new table.
     * @param cards An array of <code>Card</code>s; cards need
     * not be placed in order, but should be in pairs.
     * @param height An <code>int</code> of the height 
     * (number of rows) of the table.
     * @param width An <code>int</code> of the width 
     * (number of columns) of the table.
     * @return An 2D array of <code>Card</code> objects,
     * representing a table of cards.
     * @throws IllegalArgumentException if the given cards are
     * empty, or the height and/or width is non-positive.
     */
    public void setTable(Card[] cards, 
                              int height, int width) {
        if (cards.length == 0)
            throw new IllegalArgumentException(
                "An empty array of cards given."
            );
        if (height <= 0 || width <= 0)
            throw new IllegalArgumentException(
                "A non-positive height/width of table given."
            );
        Card[][] newTable = new Card[height][width];
        int i = 0;
        for (int row = 0; row < height; row++) {
            for (int col = 0; col < width; col++) {
                if (i >= cards.length) {
                    setTable(newTable, cards.length);
                    return;
                }
                newTable[row][col] = new Card(cards[i]);
                i++;
            }
        }
        setTable(newTable, cards.length);
    }

    /** Prints the table of cards on the screen. */
    public void printTable() {
        System.out.println();
        System.out.print("    ");    // Empty space at the top-left corner
        for (int col = 1; col <= table[0].length; col++)
            System.out.print(" " + col);
        System.out.println();
        System.out.print("   +");     // Margin of the top-border
        for (int col = 1; col <= table[0].length; col++)
            System.out.print("--");
        System.out.println();
        for (int row = 1; row <= table.length; row++) {
            System.out.printf("%2d |", row);
            for (Card c : table[row - 1]) {
                if (c != null)
                    System.out.printf("%2c", c.getShownFace());
                else
                    System.out.printf("%2c", NO_CARD);
            }
            System.out.println();
        }
        System.out.println();
    }

    /**
     * Checks if the two cards match. They matches each other
     * if they have the same value and are both facing up.
     * @param card1 An <code>Card</code> object representing the
     * first card.
     * @param card2 An <code>Card</code> object representing the
     * second card.
     * @return A <code>boolean</code> indicating whether the two
     * cards match or not.
     */
    private boolean match(Card card1, Card card2) {
        return card1 != null && card2 != null 
                && card1.isFacingUp() && card2.isFacingUp() 
                && card1.equals(card2);
    }

    /**
     * Handles player's attempt to match two cards.
     * The position of each card should be specified using a
     * two-element array. The first element is the row in which
     * the card is and the second element is the column.
     * Counting of rows and columns start from 1, corresponding 
     * to the row and column numbers as displayed to the player.
     * @param pos1 A two-element array of <code>int</code> of
     * the position of the first card in the table.
     * @param pos2 A two-element array of <code>int</code> of
     * the position of the second card in the table.
     * @throws IllegalArgumentException if the input is not
     * a two-element array of <code>int</code>, or the position
     * specified is out of bound or contains no card, or the
     * card has already been matched.
     */
    private void matchingAttempt(int[] pos1, int[] pos2) 
                    throws IllegalArgumentException {
        IllegalArgumentException posException
            = new IllegalArgumentException(
                "An invalid card position given."
            );
        if (pos1.length != 2 || pos2.length != 2)
            throw posException;
        Card card1, card2;
        try {
            card1 = table[pos1[0] - 1][pos1[1] - 1];
            card2 = table[pos2[0] - 1][pos2[1] - 1];
        } catch (ArrayIndexOutOfBoundsException e) {
            throw posException;
        }
        if (card1 == null || card2 == null)
            throw posException;
        if (card1.isFacingUp() || card2.isFacingUp())
            throw new IllegalArgumentException(
                "One of the chosen cards already matches"
                + " another card."
            );
        card1.turnFaceUp();
        card2.turnFaceUp();
        clearScreen();
        printTable();
        if (card1 != card2 && match(card1, card2))
            numMatch += 2;
        else {
            try {
                Thread.sleep(1000);     
                // Pause 1s for player to check the cards
            } catch (Exception e) {
                System.err.println(e.getMessage());
            }
            card1.turnFaceDown();
            card2.turnFaceDown();
        }
    }

    /**
     * Rearranges the table of cards.
     */
     private void shuffle() {
        Random rand = new Random();
        int targetRow = 0;
        int targetCol = 0;
        for (int row = 0; row < table.length; row++) {
            for (int col = 0; col < table[row].length; col++) {
                targetRow = rand.nextInt(table.length);
                targetCol = rand.nextInt(table[targetRow].length);
                swapCard(row, col, targetRow, targetCol);
            }
        }
    }

    /**
     * Swaps the two cards on the table.
     * @param row1 An <code>int</code> of the index position of
     * which row the first card is in (starting from 0).
     * @param col1 An <code>int</code> of the index position of
     * which column the first card is in (starting from 0).
     * @param row2 An <code>int</code> of the index position of
     * which row the second card is in (starting from 0).
     * @param col2 An <code>int</code> of the index position of
     * which column the second card is in (starting from 0).
     */
     private void swapCard(int row1, int col1, int row2, int col2) {
         Card copy1 = table[row1][col1];
         table[row1][col1] = table[row2][col2];
         table[row2][col2] = copy1;
     }

    /** Clears the screen by simply outputting several empty lines. */
    public void clearScreen() {
        for(int i = 0; i < 70; i++) 
            System.out.println();
    }

    /** Checks if all cards have matched. 
     * @return A <code>boolean</code> indicating whether
     * all cards have matched.
     */
    private boolean allMatched() {
        return numMatch > 0 && numMatch == numCards;
    }

    /**
     * Prompts for player input of the positions of two
     * cards to be turned face up.
     * <p>
     * The input is in the form 
     * "<i>r1</i>,<i>c1</i> <i>r2</i>,<i>c2</i>"
     * (quotation marks not included) where <i>r1</i>,
     * <i>c1</i> is the row and column number of the first
     * card (starting from 1), and <i>r2</i>, <i>c2</i>
     * for the second card.
     * @return An 2D array of <code>int</code>, the first
     * element being an two-element array of the position
     * of the first card (position counting from 1), and
     * the second being the position of the second card.
     */
    public int[][] promptInput(Scanner keyboard) {
        boolean inputOk = false;
        int[] pos1 = new int[2];
        int[] pos2 = new int[2];
        keyboard.reset();
        keyboard.useDelimiter(",|\\s");
        printTable();
        System.out.println("Please enter the positions of"
            + " the two cards.");
        System.out.println("Please separate the two positions"
            + " with exactly one space;");
        System.out.println("and for each position, enter the"
            + " row number, followed by a comma, and then a"
            + " column number (no space inbetween).");
        System.out.println("For example, \"1,1 1,2\" means"
            + " turns the card at position (1,1) and the card"
            + " at position (1,2). Quotation marks are not"
            + " included in the input.");
        do {
            try {
                pos1[0] = keyboard.nextInt();
                pos1[1] = keyboard.nextInt();
                pos2[0] = keyboard.nextInt();
                pos2[1] = keyboard.nextInt();
                inputOk = true;
            } catch (Exception e) {
                System.out.println("\nInvalid input."
                    +" Please try again.");
            } finally {
                keyboard.nextLine();
            }
        } while (!inputOk);
        keyboard.reset();
        int[][] pos = {pos1, pos2};
        return pos;
    }

    /**
     * Handles the actual playing within in a game.
     * The game should be ready for played. If not ready,
     * an exception will be thrown. This is usually due to
     * the game have not been set appropriately via one of
     * the {@link #newGame()} methods.
     * @param keyboard A <code>Scanner</code> object for
     * reading user input.
     * @throws IllegalStateException when the game is not
     * ready for playing.
     */
    public void play(Scanner keyboard) 
                throws IllegalStateException {
        if (!ready)
            throw new IllegalStateException(
                "Game not ready. Sets appropriate settings"
                + " before starting to play the game."
            );
        int[][] pos;
        boolean validAttempt;
        while (!allMatched()) {
            pos = promptInput(keyboard);
            try {
                matchingAttempt(pos[0], pos[1]);
                clearScreen();
            } catch (IllegalArgumentException e) {
                System.out.println("\n" + e.getMessage());
                System.out.println();
            }
        }
        printTable();
        System.out.println("\nYou win!");
    }

    public static void main(String[] args) {
        Scanner keyboard = new Scanner(System.in);
        MemoryMatching game = new MemoryMatching();
        game.newGame();
        game.play(keyboard);
    }
}